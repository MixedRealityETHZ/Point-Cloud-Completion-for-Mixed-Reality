using System;
using System.Collections;
using System.IO;
using UnityEngine;
using UnityEngine.UIElements;
using Tutorials;
using System.Runtime.InteropServices.ComTypes;
using System.Net.NetworkInformation;
using Microsoft.MixedReality.Toolkit.Input;
using UnityEngine.Android;
using System.Data.Common;

public class PointCloud
{
    private ArrayList points;
    private ArrayList colors;
    private int numberOfPoints;
    public Matrix4x4 cameraMatrix;
    private float[] coordinates;

    public int Count
    {
        get => numberOfPoints;
    }

    public ArrayList Points
    {
        get => points;
    }

    public ArrayList Colors
    {
        get => colors;
    }

    public Vector3 LeftHandPosition 
    {
        get;
        set;
    }

    public Vector3 RightHandPosition
    {
        get;
        set;
    }

    /// <summary>
    /// Constructor creating a pointcloud from a given array of points.
    /// Applies distance filtering at the same time
    /// </summary>
    /// <param name="coordinates"></param>
    /// <param name="distance_threshold"></param>
    /// <exception cref="ArgumentNullException"></exception>
    /// <exception cref="ArgumentOutOfRangeException"></exception>
    public PointCloud(float[] coordinates) //, double distance_threshold)
    {
        if (coordinates == null)
            throw new ArgumentNullException(nameof(coordinates));
        if (coordinates.Length % 3 != 0)
            throw new ArgumentException("Length of coordinates must be divisible by 3");
        if (coordinates.Length == 0)
            throw new ArgumentOutOfRangeException("Point cloud must contain at least one point");

        int nPoints = coordinates.Length / 3;
        // Square distance threshold to compare it to squared magnitude later,
        // saves some square root computations
        //distance_threshold *= distance_threshold;

        // Reserve enough space to avoid copy operations
        points = new ArrayList(nPoints);
        colors = new ArrayList(nPoints);

        // Write points
        for (int i = 0; i < nPoints; i++)
        {
            Vector3 point = new Vector3(coordinates[3 * i], coordinates[3 * i + 1], coordinates[3 * i + 2]);

            // Filter out far points
            //if (point.sqrMagnitude > distance_threshold)
            //    continue;

            points.Add(point);
            colors.Add(Color.magenta);
        }
        // All of the inserted elements are valid
        numberOfPoints = points.Count;
    }

    public PointCloud(ArrayList points, ArrayList colors, Matrix4x4 objectPose, Matrix4x4 teachingPose_inv)
    {
        Debug.Log("In point cloud constructor");
        this.points = points;
        this.colors = colors;

        Transform(teachingPose_inv);
        Transform(objectPose);
        numberOfPoints = points.Count;
    }

    public PointCloud(string filename, Matrix4x4 objectPose, Matrix4x4 teachingPose_inv)
    {
        var start = DateTime.Now;
        FileHandler.LoadPointsFromPLY(filename, out points, out colors);
        Matrix4x4 axisTransform = Matrix4x4.identity;
        axisTransform[0, 0] = axisTransform[1, 1] = 0;
        axisTransform[1, 0] = 1;
        axisTransform[0, 1] = 1;

        Transform(teachingPose_inv);
        // Flip x and y coordinates for some reason
        //Transform(axisTransform);
        Transform(objectPose);
        numberOfPoints = points.Count;
        var end = DateTime.Now;
        Debug.Log($"Loading and transforming {filename} took {(end - start).TotalSeconds}, size of ");
    }

    public void Transform(Matrix4x4 T)
    {
        for (int i = 0; i < points.Count; ++i)
        {
            points[i] = T.MultiplyPoint((Vector3)points[i]);
        }
    }

    public void ExportToPLY(string filename)
    {
        using (StreamWriter writer = new StreamWriter(filename))
        {
            // Use same format as point clouds expoted using Open3d
            string header = string.Format("ply\nformat ascii 1.0\ncomment Generated by Floating Hands\n" +
                "element vertex {0}\n" +
                //"comment {1}\n" +
                //"comment {2}\n" +
                "property double x\nproperty double y\nproperty double z\n" +
                //"property uchar red\nproperty uchar green\nproperty uchar blue\n" +
                "end_header", numberOfPoints);
                    //LeftHandPosition == null ? "" : "Left: " + LeftHandPosition.ToString(),
                    //RightHandPosition == null ? "" : "Right: " + RightHandPosition.ToString());

            writer.WriteLine(header);
            // Write each point and its corresponding color
            for (int j = 0; j < numberOfPoints; j++)
            {
                Vector3 coordinates = (Vector3)points[j];
                Color point_color = (Color)colors[j];

                //writer.WriteLine(string.Format("{0} {1} {2} {3} {4} {5}",
                //    coordinates.x, coordinates.y, coordinates.z,
                //    (int)(point_color.r * 255), (int)(point_color.g * 255), (int)(point_color.b * 255)));
                writer.WriteLine(string.Format("{0} {1} {2}",
                    coordinates.x, coordinates.y, coordinates.z));
            }
        }

        //using (StreamWriter writer = new StreamWriter(filename.Substring(0, filename.Length - 3) + "txt"))
        //{
        //    writer.WriteLine($"{cameraMatrix[0,0]} {cameraMatrix[1,1]} {cameraMatrix[0,2]} {cameraMatrix[1,2]}");
        //}


    }

    /// <summary>
    /// Applies random down sampling with a sampling ration of expected_point/number_of_points.
    /// The expected number of points is therefore the parameter given to the function.
    /// If expected_points >= number_of_points, nothing will be done
    /// </summary>
    /// <param name="expected_points"></param>
    //public void RandomDownSample(int expected_points)
    //{
    //    // Initialize random number generator
    //    System.Random rnd = new System.Random();
    //    // Don't downsample if there are fewer points than what is expected
    //    if (expected_points >= numberOfPoints)
    //        return;

    //    // Probability of element being included in the downsampled point cloud
    //    double p = (double)expected_points / numberOfPoints;
    //    // Index of first element not belonging to downsampled array anymore
    //    int n = 0;
    //    for (int i = 0; i < numberOfPoints; i++)
    //    {
    //        // Keep element, copy it in region that contains valid points
    //        if (rnd.NextDouble() < p)
    //        {
    //            points[n] = points[i];
    //            colors[n++] = colors[i];
    //        }
    //    }
    //    numberOfPoints = n;
    //}


    /// <summary>
    /// Removes points from the point cloud that are further away than a given
    /// distance from the wrist of a hand if only one hand is tracked or the
    /// center of both wrists if both hands are tracked.
    /// </summary>
    /// <param name="distance">Maximal distance where points are still included</param>
    //public void Segment(double distance)
    //{
    //    Vector3 center;
    //    // Can't do segmentation if neither hand is tracked
    //    if (LeftHandPosition == null && RightHandPosition == null)
    //        return;

    //    if (LeftHandPosition == null) // Only right hand is tracked
    //    {
    //        center = RightHandPosition;
    //    }
    //    else if(RightHandPosition == null) // Only Left hand is tracked
    //    {
    //        center = LeftHandPosition;
    //    }
    //    else // Both Hands are tracked
    //    {
    //        center = (RightHandPosition + LeftHandPosition) / 2;
    //    }

    //    // Square distance for efficiency
    //    double sqrDistance = distance * distance;
    //    int n = 0;
    //    for (int i = 0; i < numberOfPoints; i++)
    //    {
    //        // Keep element if the distance is smaller than the threshold by
    //        // copying it in the region that contains valid points
    //        if ((((Vector3)points[i]) - center).sqrMagnitude < sqrDistance)
    //        {
    //            points[n] = points[i];
    //            colors[n++] = colors[i];
    //        }
    //    }
    //    numberOfPoints = n;

    //}


    //public void ColorFromImage(Texture2D texture)
    //{
    //    // Ignore previous color information
    //    colors.Clear();
    //    float x_offset = cameraMatrix[0, 2];
    //    float y_offset = cameraMatrix[1, 2];
    //    //float x_offset = 0;
    //    //float y_offset = 0;

    //    foreach (Vector3 point in points)
    //    {
    //        // Convert 3d point in world coordinates to homogeneous point
    //        Vector4 homogeneous_point = point;
    //        homogeneous_point.w = 1;
    //        // Project to image plane (https://en.wikipedia.org/wiki/Camera_resectioning)
    //        // projected = z * [u, v, 1]^T = M * [x, y, z, 1]^T
    //        Vector3 projected = cameraMatrix * homogeneous_point;

    //        // Convert to homogeneous coordinates, z coordinate must be 1
    //        projected /= projected.z;

    //        // Translate to have the center at the correct place
    //        projected.x += x_offset;
    //        projected.y += y_offset;

    //        // Normalize and flip along the y axis
    //        float u = projected.x / texture.width;
    //        float v = 1 - (projected.y / texture.height);

    //        // Assign the current point the right color corresponding to its projection onto
    //        // the image plane
    //        if (u >= texture.width || u < 0 || v >= texture.height || v < 0)
    //        {
    //            colors.Add(Color.clear);
    //        }
    //        else
    //        {
    //            colors.Add(texture.GetPixelBilinear(u, v));
    //        }
    //    }
    //}
}
